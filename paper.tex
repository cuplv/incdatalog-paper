%% For double-blind review submission
\documentclass[acmlarge,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{listings}
\lstset{}

\usepackage{hyperref}
\hypersetup{colorlinks = true,linkcolor = blue, urlcolor=blue}

\usepackage{tikz}
\usetikzlibrary{tikzmark}

\usepackage{xcolor}


\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

% Darker versions (dRed, dBlue, etc.) of common colours;
% pure red/blue/green are violently garish, and too light in monochrome.
%
% dDkRed, etc. are darker still.
% dLight[er]{Blue|Purple} are lighter colours suitable for backgrounds.
%
% dFaint, dGray, dDark, dAlmostBlack are shades of gray.
%
\definecolor{dRed}{rgb}{0.65, 0.0, 0.0}
\definecolor{dDkRed}{rgb}{0.35, 0.0, 0.0}
\definecolor{dGreen}{rgb}{0.0, 0.65, 0.0}
\definecolor{dDkGreen}{rgb}{0.0, 0.35, 0.0}
\definecolor{dBlue}{rgb}{0.0, 0.0, 0.65}
\definecolor{dLightBlue}{rgb}{0.4, 0.4, 0.9}
\definecolor{dLighterBlue}{rgb}{0.8, 0.8, 1.0}
\definecolor{dDkBlue}{rgb}{0.0, 0.0, 0.45}
\definecolor{dLightPurple}{rgb}{0.9, 0.5, 0.9}
\definecolor{dLighterPurple}{rgb}{1.0, 0.7, 1.0}
\definecolor{dPurple}{rgb}{0.65, 0.0, 0.65}
\definecolor{dDigPurple}{rgb}{0.5, 0.0, 0.5}
% \definecolor{DDIGPURPLE}{rgb}{0.5, 0.0, 0.5}  % laughable
\definecolor{dFaint}{rgb}{0.7, 0.7, 0.7}
\definecolor{dGray}{rgb}{0.5, 0.5, 0.5}
\definecolor{dDark}{rgb}{0.2, 0.2, 0.2}
\definecolor{dAlmostBlack}{rgb}{0.1, 0.1, 0.1}

%%% ------- Fungi code in latex listings:
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkpurple}{rgb}{0.5,0,0.5}
\lstset{emph={Nm, Nat, Ref, Type, type, match, with, if, then, else, not, in, let, letrec, ref, get, thunk, force, scope, leaf, NmSet, Nat, Nm, idxtm, nmtm},
  %emphstyle={\color{blue}\bfseries},
  emphstyle={\bfseries},
  keywordstyle={\bfseries},
  commentstyle={\color{darkpurple}\ttfamily},
  language=C,
  showstringspaces=false,
}%
\lstset{emph={[2]%  
    true, false,
    },emphstyle={[2]\color{darkgreen}\bfseries}%,
}%
\newcommand{\code}[1]{\lstinline[basicstyle=\ttfamily]|#1|}
\newcommand{\hlcode}[1]{{\hl{\texttt{#1}}}}
\newcommand{\vttfamily}{\fontfamily{cmvtt}\selectfont}
\lstset{
%basicstyle=\fontsize{7}{8}\ttfamily,
basicstyle=\fontsize{8}{9}\ttfamily,
mathescape=true,
literate={lam~}{$\lambda$}1
         %%%%%%%%%%% Arrows
         %%%%%%%%%%% ---------------------
         {...}{${\color{blue}{\cdots}}$}3
         {=>}{$\Rightarrow$}2
         {<=}{$\leq$}2
         {->}{$\rightarrow$}2
         {nm->}{$\rightarrow$}2 %-- Name term function sort
         {idx->}{$\rightarrow$}2 %-- Index term function sort
         {idx=>}{$\Rightarrow$}2 %-- Kind arrow: sort to kind
         %% {->}{${\color{dBlue}{\rightarrow}}$}2
         %% {nm->}{${\color{dPurple}{\rightarrow}}$}2 %-- Name term function sort
         %% {idx->}{${\color{dRed}{\rightarrow}}$}2 %-- Index term function sort
         %% {idx=>}{${\color{dRed}{\Rightarrow}}$}2 %-- Kind arrow: sort to kind
         %%%%%%%%%% Balanced delims:
         %%%%%%%%%% --------------------------------
         % {{ ... }} = Name set literals (index terms)
         {<~}{${\color{dRed}{\left\{\right.}}$}1
         {~>}{${\color{dRed}{\left.\right\}}}$}1
         % [[ ... ]] = Annotations of types with index terms (e.g., name sets)
         {[[}{${\color{dRed}{\left[\right.}}$}1
         {]]}{${\color{dRed}{\left.\right]}}$}1
         % <[ ... ]> = Annotations of names (e.g., Write scope)
         {<[}{${\color{dRed}{\left<\right.}}$}1
         {]>}{${\color{dRed}{\left.\right>}}$}1
         % [< ... >] = Thunk boundaries in concrete expression syntax
         {[<}{${\color{blue}{\left\{\right.}}$}1
         {>]}{${\color{blue}{\left.\right\}}}$}1
         % << ... ,, ... >> = Binary name composition; primitive form
         {<<}{${\color{dPurple}{\left<\right.\hspace{-4pt}\left<\right.}}$}1
         {>>}{${\color{dPurple}{\left.\right>\hspace{-4pt}\left.\right>}}$}1
         {,,}{${\color{dPurple}{,}}$}1
         %%%%%%%%%%
         %%%%%%%%%% Operators, and index term syntax:
         %%%%%%%%%% ---------------------------------
         {~@~}{${\color{dPurple}{\bullet}}$}1 %-- Binary name composition (for Nm sort)
         {~@@~}{${\color{dRed}{\bullet}}$}1 %-- Binary name composition (for NmSet sort)
         {~*}{${}^{{\color{dRed}{\ast}}}$}1 %-- Kleene star; for an index term function over an initial set
         {@}{{\textcolor{violet}{@}}}1 %-- Name literal/constant
         {^}{${\color{dRed}{\bot}}$}1 %--- Apart symbol
         {forall~}{${\color{dRed}{\forall}}$}1 %--- Forall index terms
         {exists~}{${\color{dRed}{\exists}}$}1 %--- Exists index term
         {writeset~}{${\color{dRed}{\rhd}}$}1  %--- Write set (part of a computation type)
         %%%%%%%%% Sorts:
         %{NmSet}{{\color{dRed}{NmSet}\color{black}}}4
         %% {leaf}{{\color{dPurple}{leaf}\color{black}}}3
         %% {Nm~}{{\color{dPurple}{Nm}\color{black}}}2
         %% %{Nat~}{{\color{dRed}{Nat}\color{black}}}4
         {Nat~}{Nat}4
         %% %%%%%%%%%% Declarations
         %% %%%%%%%%%% ------------------------------------
         %% {idxtm}{{\color{dRed}{idxtm}\color{black}}}4
         %% {nmtm}{{\color{dPurple}{nmtm}\color{black}}}4
}


\begin{document}

%% Title information
\title[Short Title]{Patchwork: Incremental Computation for Static Analysis}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Programmers who use static analyses in their normal workflow will frequently demand the results of these analyses multiple times. For example, when working on code in an IDE, a programmer may make multiple small edits and request the results of an anlysis after each one. Since these edits are likely to be minor, performing the entire analysis from scratch each time is inefficient. This is a prime application for \textit{incremental computation} (insert typical IC story). 

Incremental computation is reasonably well understood for standard Datalog, which can express a small class of analyses. However, more expressiveness is needed to implement complex lattice-based analyses, particularly on infinite-height lattices, such as an interval analysis. We present the Patchwork framework, which extends the Datalog-based approach to allow for incremental implementations of general static analyses.

\begin{figure}
\begin{lstlisting}
type Q
type Inv
type VisitRes = NoChange | Change Inv

let visitloc : Inv -> Loc -> VisitRes =
  lam~inv.lam~loc.
    ...
    ...   // subcase: Update the invariant mapping:
    ...   let inv' = update inv loc absstate ;
    ...   Change inv'
    ...

letrec loop : Inv -> Q -> Inv =
  lam~inv.lam~q.
    match pop q with
      None => inv
      Some q loc =>
         match visitloc loc inv with
           NoChange   => loop inv q
           Change inv => loop inv (push q (succof loc))    
\end{lstlisting}
\caption{Analysis loop: Each ``visit'' to a program location has the
  potential to \code{update} the invariant mapping \code{inv}; the
  queue~{q} controls the schedule of these visits. }
\end{figure}

\begin{figure}
\begin{lstlisting}
/// Version with explicit naming strategy
type Q[X:NmSet]
type Inv[X:NmSet]
type VisitRes[X:NmSet] = NoChange | Change (Inv[X])

let visitloc : Inv[X] -> Loc[Y] -> exists Z|Z^X. VisitRes[X^Z] =
  lam~inv.lam~loc.
    ...
    ...   // Construct a name Z such that Z^X
    ...   let name : Nm[Z] = ... ;
    ...   let inv' = update inv name loc absstate ;
    ...   Change inv'
    ...

letrec loop : Inv[X] -> Q[Y] -> exists Z|Z^X. Inv[X^Z] =
  lam~inv.lam~q.
    match pop q with
      None => inv
      Some q loc =>
         match visitloc loc inv with
           NoChange   => loop inv q
           Change inv => loop inv (push q (succof loc))
\end{lstlisting}
\caption{Analysis loop: Each ``visit'' to a program location has the
  potential to \code{update} the invariant mapping \code{inv}; the
  queue~{q} controls the schedule of these visits. }
\end{figure}

%\newcommand{\TabYes}{\ensuremath{\ding{52}}}
%\newcommand{\TabNo}{\ensuremath{\ding{53}}}
\newcommand{\TabYes}{\ensuremath{\blacksquare}}
\newcommand{\TabNo}{\ensuremath{\square}}

\begin{table}
\begin{tabular}{|p{1.3in}p{1.5in}||ccc|l|}
  \hline
  \textbf{program domain} &
  \textbf{system feature} & Flix & IncA & Datafun & \emph{this paper}
  \\
  \hline
  general &
  first-class  
  fixed points & \TabNo & \TabNo & \TabYes & \TabYes
  \\
  general &
  user-defined
  datatypes & \TabYes & ? & \TabYes & \TabYes
  \\
  \hline
  datalog &
  datalog engine & \TabYes & \TabYes & \TabYes & \TabYes~(definable)
  \\
  \hline
  program analysis &
  user-defined lattices & \TabYes & \TabYes & \TabNo & \TabYes
  \\
  program analysis &
  non-monotone 
  widening
  & \TabYes & \TabNo & n/a & \TabYes
  \\
  program analysis &
  relational 
  analysis
  & ? & \TabNo? & n/a & \TabYes
  \\
  \hline
\end{tabular}
\caption{By-feature comparison with related work on datalog semantics, and (incremental) datalog for program analysis.}
\label{tab:relatedwork}
\end{table}

\begin{table}[]
    \centering
    \begin{tabular}{|c|l|c|c|c|c|}
        \hline
        \# & stmt & result & 1: x = 9 & 6: y += 2 & 4: x -= 2 \\
        \hline
        1 & x = 10; & & & &\\
        \hline
        2 & y = 0; & x + y $\le$ 10 & \textcolor{red}{x + y $\le$ 9} & x + y $\le$ 9 & x + y $\le$ 9\\
        \hline
        3 & while x > 0: & x + y $\le$ 10 & \textcolor{red}{x + y $\le$ 9} & \textcolor{red}{x + y $\le \infty$} & \textcolor{red}{x + y $\le$ 9}\\
        \hline
        4 & \hspace*{0.3cm} x- - & x + y $\le$ 9 & \textcolor{red}{x + y $\le$ 8} & \textcolor{red}{x + y $\le \infty$} & \textcolor{red}{x + y $\le$ 7}\\
        \hline
        5 & \hspace*{0.3cm} if* & & & &\\
        \hline
        6 & \hspace*{0.6cm} y++ & x + y $\le$ 10 & \textcolor{red}{x + y $\le$ 9} & \textcolor{red}{x + y $\le \infty$} & \textcolor{red}{x + y $\le$ 9}\\
        \hline
        7 & assert(x + y $\le$ 10) & true & true & \textcolor{red}{false} & \textcolor{red}{true}\\
        \hline
    \end{tabular}
    \caption{Caption}
    \label{tab:my_label}
\end{table}

\section{Motivating Examples}

Parity analysis (requires lattice)\\
Interval analysis (requires widening)

\section{Approach: fungilang + lattice?}

Present fungilang semantics

\section{Worked examples}

go back through motivating examples: parity analysis

\begin{lstlisting}
1 x = 1;
2 while x < rand()
3   x++;
\end{lstlisting}


\subsection{Proposed Example with Relational Domain}

Consider the following simple program, which takes 1000 random walks of length 3 in $\mathbb{Z}$ and tracks how many walks end at each possible integer. (example taken from Min\'e \href{https://pdfs.semanticscholar.org/ccb9/2bfe24199455d7c4a430f756c915cd4e5ae8.pdf}{slides})
\begin{lstlisting}
1 hit = {-3:0, -1:0, 1:0, 3:0}
2 for k = 1 to 1000:
3   x = 0
4   for i = 1 to 3:
5     if random() then x++ else x--
6   hit[x] = hit[x] + 1
\end{lstlisting}

A non-relational analysis would be unable to show that \texttt{x} is in the domain of \texttt{hit} on line 6, since such a proof depends on the relationship between $i$ and $x$ in the inner for loop.  However,  using a relational abstract domain such as octagon, we can express the constraint that $|x|\leq i$ in the inner for loop.  Note that this is still insufficient to show that the result will always be odd; we could, however, combine with a parity domain to show that, not only are the results in $[-3,3]$ (from octagon), they're also in $2\mathbb{Z}+1$ (from parity).

We can easily vary the number of random walks taken or the length of each walk to ``grow'' the program and show asymptotic scaling.  However, if I understood Matt's messages correctly, that doesn't address the question of an ``edit model''.  I'll be talking to Jared about what such an edit model might look like here.

\iffalse NOTE(benno): also considered a couple other examples, noting here as alternatives that could be further pursued if neeeded:

This one needs relational analysis to statically discharge the assertion, but there's no good way I see initially to vary the size of the program.
  x = 0;
  y = 0;
  if rand():
    x = 1
  else:
    y = 1
    assert !(x && y)

This one comes directly from the original octagon analysis paper.  It also has a nice relational story, but is similarly hard to vary the size of the program, though it is straightforward to change some initial parameters for incremental edits.
    x = 10
    y = 0
    while(x > 0):
      x--;
      if(*):
        y++
    assert(x+y <= 10)  
A non-relational analysis would not be able to statically discharge the assertion, concluding only that $x\in (-\infty,10]$ and $y\in [0,\infty)$.  However, a relational domain like octagon is able to statically discharge the assertion using a loop invariant of $x+y\leq10\wedge-x-y\leq10$

I also played around for a while with string substring operations (where we'd have to relate the length of the substring to the total length of the list and the beginning index to prove accesses safe) but couldn't come up with a clean simple example to work with.



\fi

\begin{table}[]
  \centering
  \newcommand{\location}{\tikz\draw[green!65!black,fill=green!65!black] (0,0) circle (.4ex);}
  \def\arraystretch{2}
    \begin{tabular}{r|l|ccl}
        \# & Program Location & \multicolumn{3}{l}{Analysis State Progression} \\
        \midrule
        1 & \texttt{x = 10;\location} &\quad&$\{\}$\tikzmark{1a} & \\
        \hline
        2 & \texttt{y = 0;\location} &$\bot$\quad& $\{x+y\leq10\}$\tikzmark{2a} & \hspace{1em}$\{x+y\leq10\}$\tikzmark{2b}\\
        \hline
        3 & \texttt{while(x > 0)\{\location} &$\bot$\quad& $\{x+y\leq10\}$\tikzmark{3a} & \tikzmark{3b}\\
        \hline
        4 & \quad\texttt{x--;\location} &$\bot$\quad&  $\{x+y\leq9\}$\tikzmark{4a}& \\
        \hline
        5 & \quad\texttt{if(*) \{y++;\location\}} &$\bot$\quad&$\{x+y\leq10\}$\tikzmark{5a}& \\
        \hline
        6 & \quad\texttt{else \{$\epsilon$;\location\}} &$\bot$\quad& $\{x+y\leq9\}$\tikzmark{6a} & \\
        \hline
        7 & \location\texttt{\}} &$\bot$\quad& $\{x+y\leq10\}$\tikzmark{7a} & \tikzmark{7b}\\
        \hline
        8 & \location~\texttt{assert(x + y $\le$ 10)} &$\bot$\quad& $\{x+y\leq10\}$\tikzmark{8a} & \\
    \end{tabular}

    \newcommand{\abovetext}{10pt}
    \newcommand{\belowtext}{-4pt}
    
    \begin{tikzpicture}[overlay,remember picture, shorten >=-3pt]
      \coordinate (1a) at ([xshift=-0.46em]pic cs:1a) ;
      \coordinate (2a) at (pic cs:2a);
      \coordinate (3a) at (pic cs:3a);
      \coordinate (4a) at (pic cs:4a);
      \coordinate (5a) at (pic cs:5a);
      \coordinate (6a) at (pic cs:6a);
      \coordinate (7a) at (pic cs:7a);
      \coordinate (8a) at (pic cs:8a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a) -- ([yshift = \abovetext]1a|-2a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-2a) -- ([yshift = \abovetext]1a|-3a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-3a) -- ([yshift = \abovetext]1a|-4a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-4a) -- ([yshift = \abovetext]1a|-5a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-4a)
      to [out=270,in=90] ([xshift=0.6em,yshift=0.2em] pic cs:5a)
      to [out=270,in=90] ([yshift = \abovetext]1a|-6a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-5a)
      to [out=270,in=90] ([xshift=-5.25em,yshift=0.25em] pic cs:6a)
      to [out=270,in=90] ([yshift = \abovetext]1a|-7a);
      \draw[->, blue!75!black] ([yshift=\belowtext]1a|-6a) -- ([yshift = \abovetext]1a|-7a);
      \draw[->, blue!75!black,rounded corners=4pt] ([yshift=4pt,xshift=1pt] pic cs:7a) -| ([xshift=-1pt] pic cs:3b) |- ([xshift=-5.5em, yshift=3pt]pic cs:2b);
%      \draw[->, blue!75!black,rounded corners=4pt] ([yshift=4pt,xshift=1pt] pic cs:7a) -| ([yshift=-5pt, xshift=-1pt] pic cs:7b) |- ([xshift=-5.5em, yshift=3pt]pic cs:8b);
      \draw[->, blue!75!black,rounded corners=3pt] ([yshift=3pt,xshift=-5.25em] pic cs:2a) -| ([xshift=-5.65em,yshift=0.35em] pic cs:6a) |- ([yshift=3pt,xshift=-5.5em] pic cs:8a);
    \end{tikzpicture}
    
    \caption{ Visualization of fix-point computation for a program analyzer performing octagon analysis on the example program from Fig.~\ref{???}.
      Program locations in the abstract syntax are denoted by green circles in the concrete syntax.  The blue arrows illustrate a ``trace'' of the worklist/fix-point computation, showing the propagation of dataflow analysis results through the program.
%      Thus, the full history of partially-computed abstract states at a particular location is recorded from left to right in the ``Analysis State Progression'' column.
    }
    \label{tab:ATT}
\end{table}

\section{Evaluation}

We evaluated our approach on a spread of analyses and target programs.

Analyses:\\
Simple interval? Points-to? Interprocedural?

Programs:\\
IncA benchmarks? Flix benchmarks? Both?

Edit model:\\
Adopt IncA approach? Commit history? Other?

We compare to {Flix/IncA}?

\section{Future work/Extensions}

Interprocedural? Or doing that now?

\section{Related Work}

Incremental Datalog framework (which?):

Flix: the Patchwork framework extends the work of the Flix authors. Specifically, Flix provides a Datalog extension with the ability to reason about lattices. Patchwork extends work done on incremental Datalog evaluation, to, effectively, incremental Flix evaluation. Notably, Flix evaluates (large numbers) of rules in the course of (example). This includes significant redundancy, due to (facts about their dependency analysis). Our approach automatically tracks these dependencies and improves performance by (numbers).

IncA: the IncA papers gives an algorithm for performing incremental evaluation of lattice-aware Datalog-style programs. The approach takes advantage of properties of monotonic operators on lattices to quickly update aggregations and Datalog relations. However, the monotonicity restriction rules out important program analyses, such as (those that depend on widening). The IncA framework cannot express our second worked example. Additionally, (performance).

\section{Conclusion}

Existing state-of-the-art approaches to incremental program analysis are not fully general. Incremental Datalog engines are restricted to the simple declarative model, and even more complex approaches such as IncA restrict the types of operators an analysis user can work with. The Patchwork framework provides a fully general (is this true?) approach to incremental static analysis. Our use of Adapton also improves efficiency by (numbers). This represents a significant advance in the state of incremental static analysis.

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
